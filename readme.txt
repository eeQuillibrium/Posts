Тестовое задание, ozon fintech
 
Для запуска:
1. docker-compose up

Mutations:
  1. createComments: создает комментарии в бд и записывает в канал уведомление, 
  которое приходит в Subscriptons notification(postId: Int!), из которого читает клиент, на чтение из канала дается 5 секунд
  2. createPost: создает пост
  3. createUser: создает юзера

Queries:
  1. posts: возвращает посты без подгрузки комментариев с offset-limit пагинацией
  2. post: подгружает(кеширует) в in-memory комментарии по postID и возвращает limit комментариев на каждом уровне
  3. paginationComment: возвращает limit комментариев верхнего уровня со любой вложенностью

Subscriptions:
  notification: читает по postId: Int! из канала все приходящие 



!с N+1 боролся при помощи dataloaders, которые объединяют выборку 
для запроса в один запрос SELECT * FROM comments IN ()
!для nested комментариев сделал запись в gqlgen.yml, чтобы он сгерерировал отдельный резолвер и читал из бд комменты 
с parent_id comment-а, который запрашивается

Вот что вводил обычно на тесте:

//queries//
Mutations: 

createUsers:
mutation createUser {
  t1: createUser(input: {login: "balora", password:"qwerty123", name:"nikita"})  

  t2: createUser(input: {login: "babagi", password:"qwerty43", name:"andrew"})  

  t3:createUser(input: {login: "silniduhom", password:"qwerty5", name:"misha"})  
}  


createPosts:
mutation createPost {
  t1: createPost(input:{header: "how to write", text: "simple", userId: 1})  
  t2: createPost(input:{header: "how to lift", text: "strong", userId: 1})  
  t3: createPost(input:{header: "how to create", text: "creative", userId:2})  
  t4: createPost(input:{header: "how to delete", text: "with rollback", userId: 3})  
}  
  
createComments:  
mutation createComment {  
  t1: createComment(input:{text:"cool", userId:1, postId:1, level: 1})  
  t2: createComment(input:{text:"fantastic", userId:1, postId:1, level: 1})  
  t3: createComment(input:{text:"bright", userId:1, postId:1, level: 2, parentId: 1})
  t4: createComment(input:{text:"super", userId:1, postId:1, level: 2, parentId: 2})  
}  
  
Queries:  
posts:
query posts {  
  t1: posts(input: {offset: 0, limit: 10}) {  
    id  
    header  
    text  
    createdAt  
  }  
  t2: posts(input: {offset: 0, limit: 1}) {  
    id  
    header  
    text  
    createdAt  
  }  
  t3: posts(input: {offset: 1, limit: 10}) {  
    id  
    header   
    text  
    createdAt  
  }  
}  
post:
query post {  
  t1: post(postId: 2, limit: 3) {  
    id  
    header  
    text  
    comments {  
      text  
    }  
  }  
  t2: post(postId: 1, limit: 1) {  
    id  
    header  
    text  
    comments {  
      text  
    }  
  }  
  t3: post(postId: 1, limit: 3) {  
    id  
    header  
    text  
    comments {  
      text  
      comments {  
        text  
      }  
    }  
  }  
   t4: post(postId: 1, limit: 2) {  
    id  
    header  
    text  
    comments {  
      text  
      id  
      parentId  
      comments {  
        text   
        id   
        parentId  
      }  
    }  
  }  
}  
  
!!!paginationComment: может использоваться только после исполнения post (подгрузки комментов в in-memory)  
query paginationComment {   
  t1: paginationComment(postId: 1,  pagination: {offset: 1, limit:5}) {  
    text  
    comments {  
      text  
    }  
  }  
  t2: paginationComment(postId: 1,  pagination: {offset: 0, limit:10}) {  
    id  
    level  
    comments {  
      id  
      level  
      parentId  
      comments {      
        id  
        level  
      	parentId  
          
      }  
    }  
  }  
  t3: paginationComment(postId: 1,  pagination: {offset: 10, limit:100}) {  
    text   
    comments {  
      text  
    }  
  }  
   
}  
Subscription:  
subscription notification {  
  notification(postId: 1) {  
    text  
    issuerId  
  }  
}  
mutation createComment {  
  t1: createComment(input:{text:"mega", userId:1, postId:1, level: 1})   
}  


//==========================Для себя=======================//
// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

type Comment struct {
	ID        int        `json:"id"`
	PostID    int        `json:"postId" db:"post_id"`
	ParentID  *int       `json:"parentId,omitempty" db:"parent_id"`
	UserID    int        `json:"userId" db:"user_id"`
	Text      string     `json:"text"`
	Level     int        `json:"level"`
	CreatedAt string     `json:"createdAt" db:"created_at"`
	Comments  []*Comment `json:"comments"`
}

type Mutation struct {
}

type NewComment struct {
	ParentID *int   `json:"parentId,omitempty"`
	Text     string `json:"text"`
	UserID   int    `json:"userId"`
	PostID   int    `json:"postId"`
	Level    int    `json:"level"`
}

type NewPost struct {
	Header string `json:"header"`
	Text   string `json:"text"`
	UserID int    `json:"userId"`
}

type NewUser struct {
	Name     string `json:"name"`
	Login    string `json:"login"`
	Password string `json:"password"`
}

type Pagination struct {
	Offset int `json:"offset"`
	Limit  int `json:"limit"`
}

type Post struct {
	ID        int        `json:"id"`
	UserID    int        `json:"userId" db:"user_id"`
	Text      string     `json:"text"`
	Header    string     `json:"header"`
	CreatedAt string     `json:"createdAt" db:"created_at"`
	IsClosed bool `json:"is_closed" db:"is_closed"`
	Comments  []*Comment `json:"comments"`
}

type Query struct {
}

type User struct {
	ID       int    `json:"id"`
	Login    string `json:"login"`
	Password string `json:"password"`
	Name     string `json:"name"`
}

type Subscription struct {
}
type Notification struct {
	Text     string `json:"text"`
	IssuerID int    `json:"issuerId"`
}





Comment:
    fields:
      comments:
        resolver: true
go run github.com/99designs/gqlgen generate 
migrate -database postgres://postgres:secret@localhost:5432/postgres?sslmode=disable -path migrations up  