package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/eeQuillibrium/posts/graph/model"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Comments is the resolver for the comments field.
func (r *commentResolver) Comments(ctx context.Context, obj *model.Comment) ([]*model.Comment, error) {
	comments, err := r.service.Comments.GetByComment(ctx, obj.ID)
	if err != nil {
		return nil, errors.New("commentResolver.Comments():\n" + err.Error())
	}
	return comments, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.NewPost) (int, error) {
	postID, err := r.service.Posts.CreatePost(ctx, &input)
	if err != nil {
		return 0, errors.New("mutationResolver.CreatePost():\n" + err.Error())
	}
	return postID, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewComment) (int, error) {
	commentID, err := r.service.Comments.CreateComment(ctx, &input)
	if err != nil {
		return 0, errors.New("mutationResolver.CreateComment():\n" + err.Error())
	}

	mu := sync.Mutex{}
	go func() {
		defer mu.Unlock()
		for {
			select { //ждем 5 секунд на чтение из Notifications resolver
			case <-time.After(5 * time.Second):
				return
			case r.notifyChan <- &model.Notification{
				Text:     input.Text,
				IssuerID: input.UserID,
			}:
				return
			}
		}

	}()
	mu.Lock()

	return commentID, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (int, error) {
	userID, err := r.service.Auth.Register(ctx, &input)
	if err != nil {
		return 0, errors.New("mutationResolver.CreateUser():\n" + err.Error())
	}
	return userID, nil
}

// ClosePost is the resolver for the closePost field.
func (r *mutationResolver) ClosePost(ctx context.Context, postID int) (bool, error) {
	isClosed, err := r.service.Posts.ClosePost(ctx, postID)
	if err != nil {
		return false, errors.New("mutationResolver.ClosePost():\n" + err.Error())
	}
	return isClosed, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, input model.Pagination) ([]*model.Post, error) {
	posts, err := r.service.Posts.GetPosts(ctx, &input)
	if err != nil {
		return nil, errors.New("queryResolver.Posts():\n" + err.Error())
	}
	return posts, err
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, postID int, limit int) (*model.Post, error) {
	comments, err := r.service.Comments.GetComments(ctx, postID)
	if err != nil {
		return nil, errors.New("queryResolver.Post():\n" + err.Error())
	}

	r.ps.LoadPost(comments, postID) //cache

	post, err := r.service.Posts.GetPost(ctx, postID)
	if err != nil {
		return nil, errors.New("queryResolver.Post():\n" + err.Error())
	}

	post.Comments = r.ps.PaginationComments(postID, 0, limit)

	return post, nil
}

// PaginationComment is the resolver for the paginationComment field.
func (r *queryResolver) PaginationComment(ctx context.Context, postID int, pagination model.Pagination) ([]*model.Comment, error) {
	return r.ps.PaginationComments(postID, pagination.Offset, pagination.Limit), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: Users - users"))
}

// Notification is the resolver for the notification field.
func (r *subscriptionResolver) Notification(ctx context.Context, postID int) (<-chan *model.Notification, error) {
	ch := make(chan *model.Notification)

	go func() {
		defer close(ch)
		for {
			time.Sleep(2 * time.Millisecond)
			select {
			case <-ctx.Done():
				r.log.Info("Subscription Closed")
				return
			case ch <- <-r.notifyChan:
				r.log.Info("readen")
			}
		}
	}()

	// We return the channel and no error.
	return ch, nil
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
