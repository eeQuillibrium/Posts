package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/eeQuillibrium/posts/graph/model"
	grapherrors "github.com/eeQuillibrium/posts/pkg/graphErrors"
)

// Comments is the resolver for the comments field.
func (r *commentResolver) Comments(ctx context.Context, obj *model.Comment) ([]*model.Comment, error) {
	var (
		comments []*model.Comment
		err      error
	)

	if r.storageMode == "POSTGRES" {
		comments, err = r.service.Comments.GetByParentComment(ctx, obj.ID)
	} else {
		comments, err = r.st.Comments.GetChildLevel(ctx, obj.ID)
	}

	if err != nil {
		return nil, grapherrors.TransformError(fmt.Errorf("commentResolver.Comments():\n %w", err))
	}

	return comments, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.NewPost) (int, error) {
	var (
		postID int
		err    error
	)
	if r.storageMode == "POSTGRES" {
		postID, err = r.service.Posts.CreatePost(ctx, &input)
	} else {
		postID, err = r.st.Posts.CreatePost(ctx, &input)
	}

	if err != nil {
		return 0, grapherrors.TransformError(fmt.Errorf("mutationResolver.CreatePost():\n %w", err))
	}

	return postID, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewComment) (int, error) {
	var (
		commentID int
		err       error
	)
	if r.storageMode == "POSTGRES" {
		commentID, err = r.service.Comments.CreateComment(ctx, &input)
	} else {
		commentID, err = r.st.Comments.CreateComment(ctx, &input)
	}

	if err != nil {
		return 0, grapherrors.TransformError(fmt.Errorf("mutationResolver.CreateComment():\n %w", err))
	}

	wg := &sync.WaitGroup{}
	wg.Add(1)
	go func() {
		defer wg.Done()
		for {
			select { //ждем 2 секунды на чтение из Notifications resolver
			case <-time.After(2 * time.Second):
				return
			case r.notifyChan <- &model.Notification{
				Text:     input.Text,
				IssuerID: input.UserID,
			}:
				return
			}
		}
	}()
	wg.Wait()

	return commentID, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (int, error) {
	var (
		userID int
		err    error
	)
	if r.storageMode == "POSTGRES" {
		userID, err = r.service.Auth.CreateUser(ctx, &input)
	} else {
		userID, err = r.st.Users.CreateUser(ctx, &input)
	}

	if err != nil {
		return 0, grapherrors.TransformError(fmt.Errorf("mutationResolver.CreateUser():\n %w", err))
	}

	return userID, nil
}

// ClosePost is the resolver for the closePost field.
func (r *mutationResolver) ClosePost(ctx context.Context, postID int) (bool, error) {
	var (
		isClosed bool
		err      error
	)
	if r.storageMode == "POSTGRES" {
		isClosed, err = r.service.Posts.ClosePost(ctx, postID)
	} else {
		isClosed, err = r.st.Posts.ClosePost(ctx, postID)
	}

	if err != nil {
		return false, grapherrors.TransformError(fmt.Errorf("mutationResolver.ClosePost():\n %w", err))
	}
	return isClosed, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, input model.Pagination) ([]*model.Post, error) {
	var (
		posts []*model.Post
		err   error
	)
	if r.storageMode == "POSTGRES" {
		posts, err = r.service.Posts.GetPosts(ctx, &input)
	} else {
		posts, err = r.st.Posts.GetPosts(ctx, input.Limit, input.Offset)
	}

	if err != nil {
		return nil, grapherrors.TransformError(fmt.Errorf("queryResolver.Posts():\n %w", err))
	}

	return posts, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, postID int, limit int) (*model.Post, error) {
	var (
		comments []*model.Comment
		post     *model.Post
		err      error
	)
	if r.storageMode == "POSTGRES" {
		comments, err = r.service.Comments.GetComments(ctx, postID)
		if err != nil {
			return nil, grapherrors.TransformError(fmt.Errorf("queryResolver.Post():\n %w", err))
		}
		post, err = r.service.Posts.GetPost(ctx, postID)
	} else {
		comments, err = r.st.Comments.GetPostComments(ctx, postID)
		if err != nil {
			return nil, grapherrors.TransformError(fmt.Errorf("queryResolver.Post():\n %w", err))
		}
		post, err = r.st.Posts.GetPost(ctx, postID)
	}

	if err != nil {
		return nil, grapherrors.TransformError(fmt.Errorf("queryResolver.Post():\n %w", err))
	}

	r.pc.LoadPost(comments, postID) //cache

	post.Comments, err = r.pc.PaginationComments(postID, 0, limit)
	if err != nil {
		return nil, grapherrors.TransformError(fmt.Errorf("queryResolver.Post():\n %w", err))
	}

	return post, nil
}

// PaginationComment is the resolver for the paginationComment field.
func (r *queryResolver) PaginationComment(ctx context.Context, postID int, pagination model.Pagination) ([]*model.Comment, error) {
	comments, err := r.pc.PaginationComments(postID, pagination.Offset, pagination.Limit)
	if err != nil {
		return nil, grapherrors.TransformError(fmt.Errorf("queryResolver.PaginationComment():\n %w", err))
	}
	return comments, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: Users - users"))
}

// Notification is the resolver for the notification field.
func (r *subscriptionResolver) Notification(ctx context.Context, postID int) (<-chan *model.Notification, error) {
	ch := make(chan *model.Notification)

	go func() {
		defer close(ch)
		for {
			time.Sleep(2 * time.Millisecond)
			select {
			case <-ctx.Done():
				r.log.Info("Subscription Closed")
				return
			case ch <- <-r.notifyChan:
				r.log.Info("readen")
			}
		}
	}()

	// We return the channel and no error.
	return ch, nil
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
